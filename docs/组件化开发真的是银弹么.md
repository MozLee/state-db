## 组件化开发真的是银弹么？
#### 是
组件化开发思路本质上是“高内聚，低耦合，强封装，强规范”，我们先谈谈这些优点：

1. 80%的组件内部行为内聚在了组件内部，良好的封装性使得这些行为可控而不扩散
2. 组件在组合使用的过程中，组件与组件之间很少存在耦合性，多人协作效率可以得到较大的提高
3. 诞生了像ant-design, element-ui 等一大批优秀的组件库，相比传统的bootstrap能提供更多的能力封装，并且不会对外污染。
4. 在框架支持下，80%以上的前端开发被转化为了“组件”，一个团队内部有了统一的对话方式和规范，历史贡献堪比始皇帝的“书同文，车同轨”。

#### 也不是
但是对于非常复杂的企业级页面来说，完完全全的组件化开发方式带来了便捷，也同时带来了困扰。
1. 复杂的业务逻辑使得我们不得不将一个功能封装成一个层层嵌套的组件，组件之间产生了层层递进的耦合关系，组件的使用往往成了类似继承的关系而非组合。而这个继承也十分不完美。比如下面的例子：
```jsx
//这是一个父组件
<div>
    ......
    <Avatar name={this.name} img={this.avatar}>
    ......
</div>

```
父组件内引用了子组件Avatar，当我修改Avatar，可能对父组件产生影响，比如样式，比如它需要多加个参数，而当我修改父组件时，也可能对子组件产生影响，比如改了个字段名，而且这个子组件有可能还会在别的地方进行调用。

2. 组件之间的强封装带来了新的问题：组件间通信，我们可以使用全局变量、父组件代理、context、redux/mobx 等方式进行组件间通信，假设我们以使用redux为例：页面的状态分布在组件内部、redux中。那么这个问题下面会有以下3个子问题：

- 哪些状态放在组件内部，哪些状态放在redux？会有不同的理解
- 是否使用context或父组件代理，会有不同的理解
- 是多个子组件connect redux，还是父组件统一connect redux，再向下传递，会有不同的理解

3. 一段相似但并不同的前端逻辑，要不要整合成一个组件？会有不同的理解
4. 针对复杂的业务逻辑，组件的粒度应该拆多大？分几层？会有不同的理解

#### 分析
从以上分析可以看出，组件化帮助我们解决了一些问题，遗留了一些问题，也带来了一些新的问题，总结一下就是。

1. 对于某一个复杂应用中的组件来说，可能的耦合点非常多
- 父/祖 组件
- 子/孙 组件
- 状态管理器（redux/mobx）

2. 对于组件的定义，层级，粒度，不同的人会有不同的看法，甚至同一个人今天和明天又是两种不同的看法
3. 业务状态分布在组件和状态管理器中，并可能随着props传递进行流转，可能随着组件的创建/销毁一并的添加和删除，bug的排查变得非常困难。


#### 解决方案
1. 业务状态收敛到状态管理器中，组件不持有业务状态，状态管理器形成一个DB层。
2. 状态的增删改查接口全部采用函数，函数负责和状态管理器交互，组件负责调用函数。函数的集合形成一个model层。
3. 组件分层归类，分为以下4类组件
    - 基础组件：完全的业务无关，允许存在内部state，并接收props。（比如button， panel等）
    - 业务展示组件：可以触发事件，纯展示，没有内部state, 只接收props进行展示，比如一个卡片，一个ListItem等。
    - 业务组件： 原生html + 基础组件 + 业务展示组件 + store connection, 不允许存在内部state，不接收props, 业务组件只允许组合，不允许嵌套(循环中的组件除外)
    - 入口组件：页面的初始化，DB表的添加与删除

4. 对于复杂的业务，尽量采用业务组件之间的组合，而避免嵌套


